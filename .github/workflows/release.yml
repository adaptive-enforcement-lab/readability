name: Release

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_docs:
        description: "Force docs rebuild"
        type: boolean
        default: false

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

# Permissions set at job level for least privilege
permissions: {}

jobs:
  # Run CI first - release only proceeds if CI passes
  ci:
    name: CI
    uses: ./.github/workflows/ci.yml
    secrets: inherit
    permissions:
      contents: read
      security-events: write

  release-please:
    name: Release Please
    runs-on: ubuntu-latest
    needs: ci
    permissions:
      contents: write
      pull-requests: write
    outputs:
      release_created: ${{ steps.release.outputs.release_created }}
      tag_name: ${{ steps.release.outputs.tag_name }}
      version: ${{ steps.release.outputs.version }}
      major: ${{ steps.release.outputs.major }}
      minor: ${{ steps.release.outputs.minor }}
    steps:
      - uses: googleapis/release-please-action@16a9c90856f42705d54a6fda1823352bdc62cf38 # v4
        id: release
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json

      - name: Output release info
        run: |
          echo "## Release Please" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Property | Value |" >> "$GITHUB_STEP_SUMMARY"
          echo "|----------|-------|" >> "$GITHUB_STEP_SUMMARY"
          echo "| Release Created | ${{ steps.release.outputs.release_created || 'false' }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Version | ${{ steps.release.outputs.version || '-' }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Tag | ${{ steps.release.outputs.tag_name || '-' }} |" >> "$GITHUB_STEP_SUMMARY"

  build-binaries:
    name: Build Binaries
    runs-on: ubuntu-latest
    needs: release-please
    permissions:
      contents: read
    if: needs.release-please.outputs.release_created == 'true'
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          - goos: darwin
            goarch: amd64
          - goos: darwin
            goarch: arm64
          - goos: windows
            goarch: amd64
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

      - uses: actions/setup-go@4dc6199c7b1a012772edbd06daecab0f50c9053c # v6
        with:
          go-version: "1.25"

      - name: Build binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          VERSION="${{ needs.release-please.outputs.version }}"
          EXT=""
          if [ "${{ matrix.goos }}" = "windows" ]; then
            EXT=".exe"
          fi
          go build -ldflags="-s -w -X main.version=${VERSION}" \
            -o readability_${{ matrix.goos }}_${{ matrix.goarch }}${EXT} \
            ./cmd/readability

      - name: Upload artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6
        with:
          name: readability_${{ matrix.goos }}_${{ matrix.goarch }}
          path: readability_*

  # Collect all binary hashes for SLSA provenance
  hash-binaries:
    name: Hash Binaries
    runs-on: ubuntu-latest
    needs: [release-please, build-binaries]
    permissions:
      contents: read
    if: needs.release-please.outputs.release_created == 'true'
    outputs:
      hashes: ${{ steps.hash.outputs.hashes }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          path: artifacts/
          pattern: readability_*

      - name: Generate hashes
        id: hash
        run: |
          cd artifacts
          # Find all binary files and generate hashes
          find . -type f -name 'readability_*' -exec sha256sum {} \; | \
            sed 's|./[^/]*/||' | \
            base64 -w0 > ../hashes.txt
          echo "hashes=$(cat ../hashes.txt)" >> "$GITHUB_OUTPUT"
          echo "Generated hashes for:"
          find . -type f -name 'readability_*' -exec basename {} \;

  # Generate SLSA provenance
  provenance:
    name: SLSA Provenance
    needs: [release-please, hash-binaries]
    if: needs.release-please.outputs.release_created == 'true'
    permissions:
      actions: read
      id-token: write
      contents: write
    # NOTE: Must use version tag (not SHA) for slsa-verifier compatibility
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v2.1.0
    with:
      base64-subjects: ${{ needs.hash-binaries.outputs.hashes }}
      upload-assets: true
      upload-tag-name: ${{ needs.release-please.outputs.tag_name }}

  upload-assets:
    name: Upload Release Assets
    runs-on: ubuntu-latest
    needs: [release-please, build-binaries, ci]
    permissions:
      contents: write
      id-token: write # Required for keyless signing with Sigstore
    if: needs.release-please.outputs.release_created == 'true'
    steps:
      - name: Download binary artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7
        with:
          path: dist/
          pattern: readability_*
          merge-multiple: true

      - name: Download SBOM artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7
        with:
          name: sbom-cyclonedx
          path: dist/

      - name: Install Cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0

      - name: Download source archives
        run: |
          cd dist
          TAG="${{ needs.release-please.outputs.tag_name }}"
          # Download GitHub-generated source archives and rename with source- prefix
          curl -sL "https://github.com/${{ github.repository }}/archive/refs/tags/${TAG}.tar.gz" \
            -o "source_${TAG}.tar.gz"
          curl -sL "https://github.com/${{ github.repository }}/archive/refs/tags/${TAG}.zip" \
            -o "source_${TAG}.zip"
          echo "Downloaded source archives:"
          ls -la source_*

      - name: Sign binaries with Cosign
        run: |
          cd dist
          for file in readability_*; do
            cosign sign-blob --yes --bundle "${file}.sig" "${file}"
          done

      - name: Create archives
        run: |
          cd dist
          for file in readability_*; do
            if [[ "$file" == *.sig ]]; then
              continue
            elif [[ "$file" == *.exe ]]; then
              base="${file%.exe}"
              zip "${base}.zip" "$file" "${file}.sig"
            else
              tar -czvf "${file}.tar.gz" "$file" "${file}.sig"
            fi
          done
          # Include source archives in checksums
          sha256sum *.tar.gz *.zip sbom.cdx.json > checksums.txt

      - name: Sign archives with Cosign
        run: |
          cd dist
          # Sign all archives (binary and source), SBOM, and checksums
          for file in *.tar.gz *.zip sbom.cdx.json checksums.txt; do
            # Skip if already signed
            [ -f "${file}.sig" ] && continue
            cosign sign-blob --yes --bundle "${file}.sig" "${file}"
          done

      - name: Upload to release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cd dist
          # Upload archives, their signatures, SBOM, and checksums
          # Note: raw binary .sig files are already included inside archives
          gh release upload ${{ needs.release-please.outputs.tag_name }} \
            *.tar.gz *.tar.gz.sig \
            *.zip *.zip.sig \
            sbom.cdx.json sbom.cdx.json.sig \
            checksums.txt checksums.txt.sig \
            --repo ${{ github.repository }}

  build-docs:
    name: Build Documentation
    runs-on: ubuntu-latest
    needs: release-please
    permissions:
      contents: write
      pages: write
      id-token: write
    if: |
      always() && !cancelled() &&
      needs.release-please.result == 'success' &&
      (needs.release-please.outputs.release_created == 'true' || inputs.force_docs == true)
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          fetch-depth: 0

      - uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548 # v6
        with:
          python-version: "3.14"

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Determine version alias
        id: version
        run: |
          if [ "${{ needs.release-please.outputs.release_created }}" == "true" ]; then
            VERSION="${{ needs.release-please.outputs.version }}"
            MAJOR="${{ needs.release-please.outputs.major }}"
            echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
            echo "alias=v${MAJOR}" >> "$GITHUB_OUTPUT"
          else
            echo "version=dev" >> "$GITHUB_OUTPUT"
            echo "alias=" >> "$GITHUB_OUTPUT"
          fi

      - name: Deploy versioned docs
        if: needs.release-please.outputs.release_created == 'true'
        run: |
          mike deploy --push --update-aliases \
            ${{ steps.version.outputs.version }} \
            ${{ steps.version.outputs.alias }} latest

      - name: Deploy dev docs
        if: needs.release-please.outputs.release_created != 'true'
        run: mike deploy --push dev

  update-tags:
    name: Update Tag Aliases
    runs-on: ubuntu-latest
    needs: [release-please, upload-assets]
    permissions:
      contents: write
    if: needs.release-please.outputs.release_created == 'true'
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          fetch-depth: 0

      - name: Update floating version tags
        run: |
          MAJOR="v${{ needs.release-please.outputs.major }}"
          TAG_NAME="${{ needs.release-please.outputs.tag_name }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create v-prefixed major version alias (e.g., v1 -> v1.5.1)
          git tag -fa "${MAJOR}" "${TAG_NAME}" -m "Alias for ${TAG_NAME}"
          git push origin "${MAJOR}" --force

          git tag -fa "latest" "${TAG_NAME}" -m "Alias for ${TAG_NAME}"
          git push origin "latest" --force

          echo "## Tag Aliases Updated" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Alias | Points To |" >> "$GITHUB_STEP_SUMMARY"
          echo "|-------|-----------|" >> "$GITHUB_STEP_SUMMARY"
          echo "| ${MAJOR} | ${TAG_NAME} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| latest | ${TAG_NAME} |" >> "$GITHUB_STEP_SUMMARY"
